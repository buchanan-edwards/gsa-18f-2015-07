{
  "name": "check-more-types",
  "description": "Additional type checks for https://github.com/philbooth/check-types.js",
  "version": "1.5.0",
  "author": {
    "name": "Gleb Bahmutov",
    "email": "gleb.bahmutov@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/kensho/check-more-types/issues"
  },
  "contributors": [],
  "devDependencies": {
    "check-types": "1.4.0",
    "coveralls": "2.11.2",
    "grunt-contrib-jshint": "0.11.0",
    "grunt-contrib-uglify": "0.7.0",
    "grunt-contrib-watch": "0.6.1",
    "grunt-deps-ok": "0.5.2",
    "grunt-gt": "0.1.4",
    "grunt-jshint-solid": "0.1.0",
    "grunt-mocha-test": "0.12.7",
    "grunt-nice-package": "0.9.2",
    "grunt-npm2bower-sync": "0.8.1",
    "grunt-readme": "0.4.5",
    "grunt-toc": "0.1.0",
    "grunt-xplain": "0.2.4",
    "lazy-ass": "0.5.3",
    "lazy-ass-helpful": "0.6.1",
    "lcov-filter": "0.0.1",
    "lodash": "3.1.0",
    "matchdep": "0.3.0",
    "pre-git": "0.1.1"
  },
  "engines": {
    "node": ">= 0.8.0"
  },
  "homepage": "https://github.com/kensho/check-more-types",
  "keywords": [
    "types",
    "type-checking",
    "duck-typing",
    "checks",
    "check-types"
  ],
  "license": "MIT",
  "main": "check-more-types.js",
  "pre-commit": [
    "npm test",
    "npm version"
  ],
  "repository": {
    "type": "git",
    "url": "git@github.com:kensho/check-more-types.git"
  },
  "scripts": {
    "test": "grunt && npm run node-test",
    "node-test": "node test/load-under-node-test.js",
    "coveralls": "node node_modules/lcov-filter/index.js cover/lcov.info test | ./node_modules/coveralls/bin/coveralls.js"
  },
  "readme": "# check-more-types v1.5.0\n\n> Additional type checks for [check-types.js](https://github.com/philbooth/check-types.js)\n\n[![NPM][check-more-types-icon] ][check-more-types-url]\n\n[![Build status][check-more-types-ci-image] ][check-more-types-ci-url]\n[![Coverage Status][check-more-types-coverage-image] ][check-more-types-coverage-url]\n[![Codacy Badge][check-more-types-codacy-image] ][check-more-types-codacy-url]\n[![Code Climate][check-more-types-code-climate-image] ][check-more-types-code-climate-url]\n[![dependencies][check-more-types-dependencies-image] ][check-more-types-dependencies-url]\n[![devdependencies][check-more-types-devdependencies-image] ][check-more-types-devdependencies-url]\n![issue](http://issuestats.com/github/kensho/check-more-types/badge/issue)\n\n[check-more-types-icon]: https://nodei.co/npm/check-more-types.png?downloads=true\n[check-more-types-url]: https://npmjs.org/package/check-more-types\n[check-more-types-ci-image]: https://travis-ci.org/kensho/check-more-types.png?branch=master\n[check-more-types-ci-url]: https://travis-ci.org/kensho/check-more-types\n[check-more-types-coverage-image]: https://coveralls.io/repos/kensho/check-more-types/badge.png\n[check-more-types-coverage-url]: https://coveralls.io/r/kensho/check-more-types\n[check-more-types-dependencies-image]: https://david-dm.org/kensho/check-more-types.png\n[check-more-types-dependencies-url]: https://david-dm.org/kensho/check-more-types\n[check-more-types-devdependencies-image]: https://david-dm.org/kensho/check-more-types/dev-status.png\n[check-more-types-devdependencies-url]: https://david-dm.org/kensho/check-more-types#info=devDependencies\n[check-more-types-codacy-image]: https://www.codacy.com/project/badge/25cb5d1410c7497cb057d887d1f3ea23\n[check-more-types-codacy-url]: https://www.codacy.com/public/kensho/check-more-types.git\n[check-more-types-code-climate-image]: https://codeclimate.com/github/kensho/check-more-types/badges/gpa.svg\n[check-more-types-code-climate-url]: https://codeclimate.com/github/kensho/check-more-types\n\n\n\nSee [Readable conditions](http://bahmutov.calepin.co/readable-conditions-using-check-typesjs.html)\nfor advice and examples.\n\n## Install\n\n**node:** `npm install check-more-types --save`\n\n    // instead of\n    var check = require('check-types');\n    // use this\n    var check = require('check-more-types');\n    console.assert(check.bit(1), 'check.bit works');\n\n**browser** `bower install check-more-types --save`\n\n    <script src=\"check-types.js\"></script>\n    <script src=\"check-more-types.js\"></script>\n\n\n* **API**\n  * [check.bit](#checkbit)\n  * [check.git](#checkgit)\n  * [check.commitId](#checkcommitid)\n  * [check.shortCommitId](#checkshortcommitid)\n  * [check.index](#checkindex)\n  * [check.oneOf](#checkoneof)\n  * [check.same](#checksame)\n  * [check.sameLength](#checksamelength)\n  * [check.allSame](#checkallsame)\n  * [check.unit](#checkunit)\n  * [check.hexRgb](#checkhexrgb)\n  * [check.bool](#checkbool)\n  * [check.emptyString](#checkemptystring)\n  * [check.empty](#checkempty)\n  * [check.unempty](#checkunempty)\n  * [check.unemptyArray](#checkunemptyarray)\n  * [check.arrayOfStrings](#checkarrayofstrings)\n  * [check.arrayOf](#checkarrayof)\n  * [check.badItems](#checkbaditems)\n  * [check.arrayOfArraysOfStrings](#checkarrayofarraysofstrings)\n  * [check.lowerCase](#checklowercase)\n  * [check.has(obj, property)](#checkhasobj-property)\n  * [check.all](#checkall)\n  * [check.schema](#checkschema)\n  * [check.schema bind](#checkschema-bind)\n  * [schema composition](#schema-composition)\n  * [check.raises(fn, validator)](#checkraisesfn-validator)\n* [Modifiers](#modifiers)\n  * [check.maybe](#checkmaybe)\n  * [check.not](#checknot)\n  * [check.verify](#checkverify)\n* [Adding your own predicates](#adding-your-own-predicates)\n  * [check.mixin(predicate, name)](#checkmixinpredicate-name)\n  * [check.mixin does not override](#checkmixin-does-not-override)\n* [Defending a function](#defending-a-function)\n  * [check.defend(fn, predicates)](#checkdefendfn-predicates)\n  * [protects optional arguments](#protects-optional-arguments)\n  * [check.defend with messages](#checkdefend-with-messages)\n  * [check.defend in module pattern](#checkdefend-in-module-pattern)\n* [Safe callback execution](#safe-callback-execution)\n  * [check.then](#checkthen)\n  * [check.promise](#checkpromise)\n\n\n#### check.defined\n\n    check.defined(0); // true\n    check.defined(1); // true\n    check.defined(true); // true\n    check.defined(false); // true\n    check.defined(null); // true\n    check.defined(''); // true\n    check.defined(); // false\n    check.defined(root.doesNotExist); // false\n    check.defined({}.doesNotExist); // false\n\n---\n\n#### check.bit\n\n    check.bit(0); // true\n    check.bit(1); // true\n    check.bit('1'); // false\n    check.bit(2); // false\n    check.bit(true); // false\n\n---\n\n#### check.git\n\n    check.git('url string');\n\n---\n\n#### check.commitId\n\n---\n\n#### check.shortCommitId\n\n---\n\n#### check.index\n\n---\n\n#### check.oneOf\n\n    var colors = ['red', 'green', 'blue'];\n    var color = 'green';\n    check.oneOf(colors, color); // true\n    check.oneOf(colors, 'brown'); // false\n\n---\n\n#### check.same\n\n    var foo = {},\n      bar = {};\n    check.same(foo, foo); // true\n    check.same(foo, bar); // false\n    // primitives are compared by value\n    check.same(0, 0); // true\n    check.same('foo', 'foo'); // true\n\n`check.same` should produce same result as `===`.\n\n---\n\n#### check.sameLength\n\n    check.sameLength([1, 2], ['a', 'b']); // true\n    check.sameLength('ab', 'cd'); // true\n    // different types\n    check.sameLength([1, 2], 'ab'); // false\n\n---\n\n#### check.allSame\n\n    var foo = {},\n      bar = {};\n    check.allSame([foo, foo, foo]); // true\n    check.allSame([foo, foo, bar]); // false\n    // primitives are compared by value\n    check.allSame([0, 0]); // true\n    check.allSame(['foo', 'foo', 'foo']); // true\n    check.allSame([false, 0]); // false\n\n---\n\n#### check.unit\n\n    check.unit(0); // true\n    check.unit(1); // true\n    check.unit(0.1); // true\n    check.unit(1.2); // false\n    check.unit(-0.1); // false\n\n---\n\n#### check.hexRgb\n\n    check.hexRgb('#FF00FF'); // true\n    check.hexRgb('#000'); // true\n    check.hexRgb('#aaffed'); // true\n    check.hexRgb('#00aaffed'); // false\n    check.hexRgb('aaffed'); // false\n\n---\n\n#### check.bool\n\n    check.bool(true); // true\n    check.bool(false); // true\n    check.bool(0); // false\n    check.bool(1); // false\n    check.bool('1'); // false\n    check.bool(2); // false\n\n---\n\n#### check.emptyString\n\n    check.emptyString(''); // true\n    check.emptyString(' '); // false\n    check.emptyString(0); // false\n    check.emptyString([]); // false\n\n---\n\n#### check.empty\n\n    check.empty([]); // true\n    check.empty(''); // true\n    check.empty({}); // true\n    check.empty(0); // false\n    check.empty(['foo']); // false\n\n---\n\n#### check.unempty\n\n    check.unempty([]); // false\n    check.unempty(''); // false\n    check.unempty({}); // false\n    check.unempty(0); // true\n    check.unempty(['foo']); // true\n    check.unempty('foo'); // true\n\n---\n\n#### check.unemptyArray\n\n    check.unemptyArray(null); // false\n    check.unemptyArray(1); // false\n    check.unemptyArray({}); // false\n    check.unemptyArray([]); // false\n    check.unemptyArray(root.doesNotExist); // false\n    check.unemptyArray([1]); // true\n    check.unemptyArray(['foo', 'bar']); // true\n\n---\n\n#### check.arrayOfStrings\n\n    // second argument is checkLowerCase\n    check.arrayOfStrings(['foo', 'Foo']); // true\n    check.arrayOfStrings(['foo', 'Foo'], true); // false\n    check.arrayOfStrings(['foo', 'bar'], true); // true\n    check.arrayOfStrings(['FOO', 'BAR'], true); // false\n\n---\n\n#### check.arrayOf\n\n```js\ncheck.arrayOf(check.unemptyString, ['foo', '']); // false\ncheck.arrayOf(check.unemptyString, ['foo', 'bar']); // true\n// can be partially applied and combined with check.schema\nvar person = {\n  first: check.unemptyString,\n  last: check.unemptyString\n};\nvar isPerson = check.schema.bind(null, person);\nvar arePeople = check.arrayOf.bind(null, isPerson);\nvar people = [{\n  first: 'foo',\n  last: 'bar'\n}];\narePeople(people); // true\n```\n---\n\nWhy would you need `check.arrayOf(predicate, x)` and not simply use `x.every(predicate)`?\nBecause `x` might not be an Array.\n\n#### check.badItems\n\nFinds items that do not pass predicate\n\n```js\ncheck.badItems(check.unemptyString, ['foo', '', 'bar']); // ['']\n```\n\n#### check.arrayOfArraysOfStrings\n\n    // second argument is checkLowerCase\n    check.arrayOfArraysOfStrings([['foo'], ['bar'}}); // true\n    check.arrayOfArraysOfStrings([['foo'], ['bar'}}, true); // true\n    check.arrayOfArraysOfStrings([['foo'], ['BAR'}}, true); // false\n\n---\n\n#### check.lowerCase\n\n    check.lowerCase('foo bar'); // true\n    check.lowerCase('*foo ^bar'); // true\n    check.lowerCase('fooBar'); // false\n    // non-strings return false\n    check.lowerCase(10); // false\n\n---\n\n#### check.has(obj, property)\n\n    var obj = {\n      foo: 'foo',\n      bar: 0\n    };\n    check.has(obj, 'foo'); // true\n    check.has(obj, 'bar'); // true\n    check.has(obj, 'baz'); // false\n    // non-object returns false\n    check.has(5, 'foo'); // false\n    check.has('foo', 'length'); // true\n\n---\n\n#### check.all\n\n    var obj = {\n      foo: 'foo',\n      bar: 'bar',\n      baz: 'baz'\n    };\n    var predicates = {\n      foo: check.unemptyString,\n      bar: function(value) {\n        return value === 'bar';\n      }\n    };\n    check.all(obj, predicates); // true\n\n---\n\n#### check.schema\n\n    var obj = {\n      foo: 'foo',\n      bar: 'bar',\n      baz: 'baz'\n    };\n    var schema = {\n      foo: check.unemptyString,\n      bar: function(value) {\n        return value === 'bar';\n      }\n    };\n    check.schema(schema, obj); // true\n    check.schema(schema, {}); // false\n\n`check.spec` is equivalent to `check.all` but with arguments reversed.\nThis makes it very convenient to create new validator functions using partial\nargument application\n\n#### check.schema bind\n\n    var personSchema = {\n      name: check.unemptyString,\n      age: check.positiveNumber\n    };\n    var isValidPerson = check.schema.bind(null, personSchema);\n    var h1 = {\n      name: 'joe',\n      age: 10\n    };\n    var h2 = {\n      name: 'ann'\n      // missing age property\n    };\n    isValidPerson(h1); // true\n    isValidPerson(h2); // false\n\nYou can use `Function.prototype.bind` or any partial application method, for example\n`_.partial(check.schema, personSchema);`.\nBecause bound schema parameter generates a valid function, you can nest checks using\nschema composition. For example let us combine the reuse `isValidPerson` as part of\nanother check\n\n#### schema composition\n\n    var teamSchema = {\n      manager: isValidPerson,\n      members: check.unemptyArray\n    };\n    var team = {\n      manager: {\n        name: 'jim',\n        age: 20\n      },\n      members: ['joe', 'ann']\n    };\n    check.schema(teamSchema, team); // true\n\n---\n\n#### check.raises(fn, validator)\n\n    function foo() {\n      throw new Error('foo');\n    }\n\n    function bar() {}\n\n    function isValidError(err) {\n      return err.message === 'foo';\n    }\n\n    function isInvalid(err) {\n      check.instance(err, Error); // true\n      return false;\n    }\n    check.raises(foo); // true\n    check.raises(bar); // false\n    check.raises(foo, isValidError); // true\n    check.raises(foo, isInvalid); // false\n\n### Modifiers\n\nEvery predicate function is also added to `check.maybe` object.\nThe `maybe` predicate passes if the argument is null or undefined,\nor the predicate returns true.\n\n#### check.maybe\n\n    check.maybe.bool(); // true\n    check.maybe.bool('true'); // false\n    var empty;\n    check.maybe.lowerCase(empty); // true\n    check.maybe.unemptyArray(); // true\n    check.maybe.unemptyArray([]); // false\n    check.maybe.unemptyArray(['foo', 'bar']); // true\n\nEvery function has a negated predicate in `check.not` object\n\n#### check.not\n\n    check.not.bool(4); // true\n    check.not.bool('true'); // true\n    check.not.bool(true); // false\n\nEvery predicate can also throw an exception if it fails\n\n#### check.verify\n\n    check.verify.arrayOfStrings(['foo', 'bar']);\n    check.verify.bit(1);\n\n    function nonStrings() {\n      check.verify.arrayOfStrings(['Foo', 1]);\n    }\n    check.raises(nonStrings); // true\n    function nonLowerCase() {\n      check.verify.lowerCase('Foo');\n    }\n    check.raises(nonLowerCase); // true\n\n---\n\n### Adding your own predicates\n\nYou can add new predicates to `check`, `check.maybe`, etc. by using `check.mixin(predicate)`\nmethod\n\n#### check.mixin(predicate, name)\n\n    function isBar(a) {\n      return a === 'bar';\n    }\n    check.mixin(isBar, 'bar');\n    check.bar('bar'); // true\n    check.bar('anything else'); // false\n    // supports modifiers\n    check.maybe.bar(); // true\n    check.maybe.bar('bar'); // true\n    check.not.bar('foo'); // true\n    check.not.bar('bar'); // false\n\nMixin will not override existing functions\n\n#### check.mixin does not override\n\n    function isFoo(a) {\n      return a === 'foo';\n    }\n\n    function isBar(a) {\n      return a === 'bar';\n    }\n    check.mixin(isFoo, 'isFoo');\n    check.isFoo; // isFoo\n    check.mixin(isBar, 'isFoo');\n    check.isFoo; // isFoo\n\n### Defending a function\n\nUsing *check-more-types* you can separate the inner function logic from checking input\narguments. Instead of this\n\n```js\nfunction add(a, b) {\n    la(check.number(a), 'first argument should be a number', a);\n    la(check.number(a), 'second argument should be a number', b);\n    return a + b;\n}\n```\n\nyou can use `check.defend` function\n\n#### check.defend(fn, predicates)\n\n    function add(a, b) {\n      return a + b;\n    }\n    var safeAdd = check.defend(add, check.number, check.number);\n    add('foo', 2); // 'foo2'\n    // calling safeAdd('foo', 2) raises an exception\n    check.raises(safeAdd.bind(null, 'foo', 2)); // true\n\n---\n\n#### protects optional arguments\n\n    function add(a, b) {\n      if (typeof b === 'undefined') {\n        return 'foo';\n      }\n      return a + b;\n    }\n    add(2); // 'foo'\n    var safeAdd = check.defend(add, check.number, check.maybe.number);\n    safeAdd(2, 3); // 5\n    safeAdd(2); // 'foo'\n\n---\n\nYou can add extra message after a predicate\n\n#### check.defend with messages\n\n    function add(a, b) {\n      return a + b;\n    }\n    var safeAdd = check.defend(add, check.number, 'a should be a number', check.string, 'b should be a string');\n    safeAdd(2, 'foo'); // '2foo'\n    function addNumbers() {\n      return safeAdd(2, 3);\n    }\n\n    function checkException(err) {\n      err.message; // 'Argument 2: 3 does not pass predicate: b should be a string'\n      return true;\n    }\n    check.raises(addNumbers, checkException); // true\n\n---\n\nThis works great when combined with JavaScript module pattern as in this example\n\n#### check.defend in module pattern\n\n    var add = (function() {\n      // inner private function without any argument checks\n      function add(a, b) {\n        return a + b;\n      }\n      // return defended function\n      return check.defend(add, check.number, check.number);\n    }());\n    add(2, 3); // 5\n    // trying to call with non-numbers raises an exception\n    function callAddWithNonNumbers() {\n      return add('foo', 'bar');\n    }\n    check.raises(callAddWithNonNumbers); // true\n\n---\n\n### Safe callback execution\n\nSometimes we want to execute a function depending on the condition, but without throwing an\nexception. For these cases, there is `check.then`\n\n#### check.then\n\n    function isSum10(a, b) {\n      return a + b === 10;\n    }\n\n    function sum(a, b) {\n      return a + b;\n    }\n    var onlyAddTo10 = check.then(isSum10, sum);\n    // isSum10 returns true for these arguments\n    // then sum is executed\n    onlyAddTo10(3, 7); // 10\n    onlyAddTo10(1, 2); // undefined\n    // sum is never called because isSum10 condition is false\n\n----\n\n#### check.promise\n\nReturns true if given object has promise methods (`.then`, etc)\n\n### Small print\n\nAuthor: Kensho &copy; 2014\n\n* [@kensho](https://twitter.com/kensho)\n* [kensho.com](http://kensho.com)\n\nSupport: if you find any problems with this library,\n[open issue](https://github.com/kensho/check-more-types/issues) on Github\n\n\n\nThis documentation was generated using [grunt-xplain](https://github.com/bahmutov/grunt-xplain)\nand [grunt-readme](https://github.com/jonschlinkert/grunt-readme).\n\n## MIT License\n\nThe MIT License (MIT)\n\nCopyright (c) 2014 Kensho\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n",
  "readmeFilename": "README.md",
  "_id": "check-more-types@1.5.0",
  "dist": {
    "shasum": "d9241ccc2833d14d0b7bfcc5f1cae6bcb148c95c"
  },
  "_from": "check-more-types@1.5.0",
  "_resolved": "https://registry.npmjs.org/check-more-types/-/check-more-types-1.5.0.tgz"
}
